- ### [Модификаторы доступа](access.modifiers//am.md)
- ### [ООП](oop//oop.md)
- ### [ПОРЯДОК СОЗДАНИЯ И УДАЛЕНИЯ ОБЪЕКТА](oop//createAndDeleteObject.md)
- ### [CТРОКИ](strings//strings.md)
- ### [ИСКЛЮЧЕНИЯ](exeption//exeption.md)
- ### [INPUT OUTPUT STREAM](io//io.md)
- ### [COLLECTIONS](collections//collections.md)






Data APi
https://www.examclouds.com/ru/java/java-core-russian/new-date-time-api





- LocalDate представляет время с годом, месяцем, днем месяца
- LocalTime представляет часы, минуты, секунды, милесекундами
- LocalDateTime комбинация вышеперечисленного





СЕРИАЛИЗАЦИЯ





-Сериализация (Serialization) - процесс преобразования структуры данных в линейную последовательность байтов
для дальнейшей
передачи или сохранения. Сериализованные объекты можно затем восстановить (десериализовать).

-Существует два способа сериализации: 1) интерфейс Serializable 2) интерфейс Externalizable

1) работает через Reflection API - класс разбирается как набор полей, каждое из которых пишется в выходной поток. Эта
   операция неоптимальна по производительности.
   1.1 запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID,
   идентификаторы полей класса);
   1.2 рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
   1.3 запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
   1.4 рекурсивную запись объектов, которые являются полями сериализуемого объекта.
- ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими
  ссылками.
- Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока.
  Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров
  родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.
- Поля класса, помеченные модификатором transient, не сериализуются.
- При стандартной сериализации поля, имеющие модификатор static, не сериализуются.
- Поля с модификатором final сериализуются как и обычные.

- если необходимо использовать кастомную сериализацию, тогда используется интерфейс Еxternalizable,  который позволяет
  применение пользовательской логики сериализации. Способ сериализации и десериализации описывается в методах
  writeExternal() и readExternal(). Во время десериализации вызывается конструктор без параметров, а потом уже на
  созданном объекте вызывается метод readExternal

- если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,
  а не метод по умолчанию :
- writeObject() - запись объекта в поток;
- readObject() - чтение объекта из потока;
- writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;
- readResolve() - позволяет заменить на себя другой объект после чтения.

- поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при
  использовании Externalizable, поскольку final поля должны быть инициализированы в конструкторе, а после этого в
  readExternal() изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект
  с final полем необходимо использовать только стандартную сериализацию.

- если поле объявлено transient, то при десериализации объекта оно принимает значение по умолчанию.





OPTIONAL
https://habr.com/ru/post/346782/
https://vertex-academy.com/tutorials/ru/java-8-optional/
https://habr.com/ru/post/225641/
https://habr.com/ru/post/540080/





- Optional избавляет от проверки на null,является контейнером (оберткой) для значений которая также может
  безопасно содержать null.

- Для создания Optional используются методы:

- Optional.of() -  нельзя передавать null
- Optional.ofNullable() - передавать null можно безопасно
- Optional.empty() - для создания пустого Optional
- Optional.get() - Для получения значения из Optional
- Optional.isPresent() - возвращает true, если значение в нем присутствует, иначе возвращает false
- Optional.ifPresent() - выполняет переданное действие, если значение в Optional присутствует, иначе игнорирует его.
- Optional.orElse() - возвращает переданное значение, если Optional пустой
- Optional.orElseGet() - если объект не найден, Optional оставляет пространство для «Варианта Б» —
  можно выполнить другой метод
- Optional.orElseThrow() - бросает переданное исключение , если Optional пустой
- Optional.map() - служит для преобразования значения внутри Optional. Если Optional пустой преобразование не
  будет происходить
- Optional.flatMap - преобразовывает значение внутри Optional, но при этом не оборачивает их





ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ





- Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.
  В качестве параметра лямбда-выражение принимает объект типа T:

public interface Predicate<T> {
boolean test(T t);
}


BinaryOperator<T> принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа T:

public interface BinaryOperator<T> {
T apply(T t1, T t2);
}


UnaryOperator<T> принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает
результат операций в виде объекта типа T:

public interface UnaryOperator<T> {
T apply(T t);
}


Function<T,R> представляет функцию перехода от объекта типа T к объекту типа R:

public interface Function<T, R> {
R apply(T t);
}


Consumer<T> выполняет некоторое действие над объектом типа T, при этом ничего не возвращая:

public interface Consumer<T> {
void accept(T t);
}


Supplier<T> не принимает никаких аргументов, но должен возвращать объект типа T:

public interface Supplier<T> {
T get();
}





Stream API
https://habr.com/ru/company/luxoft/blog/270383/





способы создания стрима:

- collection.stream() - создание стрима из коллекции.
- Stream.of(значение1,… значениеN) - из значений
- Arrays.stream(массив) - из массива
- Files.lines(путь_к_файлу) - из файла, каждая строка - отдельный элемент
- collection.parallelStream() - паралельный стрим
- Stream.iterate(начальное_условие, выражение_генерации) - бесконечный стрим
- Stream.generate(выражение_генерации) - бесконечный стрим

Методы работы со стримами:
- существует два вида методов - конвеерные и терминальные, если стрим не кончается терминальным методом, то он будет
  работать в ленивом режиме до тех пор, пока не вызовется терминальный метод.

конвеерные методы:
- filter Отфильтровывает записи и возвращает только записи, соответствующие условию
- map - Преобразует каждый элемент стрима
- sorted - Позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator
- skip - Позволяет пропустить N первых элементов
- distinct - Возвращает стрим без дубликатов (для метода equals)
- peek - Возвращает тот же стрим, но применяет функцию к каждому элементу стрима
- limit - Позволяет ограничить выборку определенным количеством первых элементов
- flatMap - Похоже на map, но может создавать из одного элемента несколько
- mapToInt - Аналог map, но возвращает числовой стрим (то есть стрим из числовых примитивов)


терминальные методы:
- collect - Представление результатов в виде коллекций и других структур данных
- forEach - Применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
- forEachOrdered - Применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует
- toArray - Возвращает массив значений стрима
- findFirst - Возвращает первый элемент из стрима (возвращает Optional)
- findAny - Возвращает любой подходящий элемент из стрима (возвращает Optional)
- count - Возвращает количество элементов в стриме


класс Collectors содержит методы:

- toList() - собирает элементы в List
- toSet() - cобирает элементы в множество
- counting() - Подсчитывает количество элементов