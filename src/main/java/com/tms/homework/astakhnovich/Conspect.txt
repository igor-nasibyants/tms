Модификаторы доступа

- Переменная или метод, объявленные без модификатора контроля доступа доступны для любого другого класса в том же пакете. Поля в интерфейсе неявно являются public, static, final, а методы в интерфейсе по умолчанию являются public.

- public - могут быть доступны из любого другого класса.

- private методы, переменные и конструкторы, которые объявлены как private в Java могут быть доступны только в пределах самого объявленного класса.

- protected в суперклассе, могут быть доступны только для подклассов в другом пакете или для любого класса в пакете класса protected, не может быть применен к классу и интерфейсам.

- static -  используется для создания переменных,методов, которые будут существовать независимо от каких-либо экземпляров, созданных для класса.
Только одна копия переменной static в Java существует вне зависимости от количества экземпляров класса.

- final - переменная - константа, метод - нельзя переопределить, класс - нельзя наследовать.

- abstract - метод с любой реализацией при переопредилении, класс задающий поведение для потомков.

- synchronized - для указания того, что метод может быть доступен только одним потоком одновременно.

- transient - указывает JVM, чтобы пропустить определённую переменную при сериализации объекта, содержащего её.

- volatile - используется, чтобы позволить знать JVM, что поток доступа к переменной всегда должен объединять свою собственную копию
переменной с главной копией в памяти.





ООП





- Абстракция - это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно,
абстракция – это набор всех таких характеристик.

- Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации
от пользователя, открыв только то, что необходимо при последующем использовании.

- Полиморфизм - это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

- Наследование - это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

- Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для
взаимодействия с данной сущностью (контракт).

- Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.
Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

- Интерфейс – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с
набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.





ПОРЯДОК СОЗДАНИЯ И УДАЛЕНИЯ ОБЪЕКТА
https://javarush.ru/groups/posts/2137-porjadok-deystviy-pri-sozdanii-obhhekta
https://javarush.ru/groups/posts/1931-ejshje-o-sborjshike-musora-





Порядок создания объекта
1) инициализируются статические переменные родительского класса
2) инициализируются статические переменные класса-потомка
3) инициализируются не статические переменные родительского класса
4) инициализируются конструктор родительского класса
5) инициализируются не статические переменные класса-потомка класса
6) инициализируются конструктор класса-потомка класса

Порядок удаления объектов
- Объекты бывают достижимые и недостижимые. Объект считается достижимым, если на него ссылается другой достижимый объект. Получается такая “цепочка достижимости”.
Она начинается при запуске программы и тянется в течение всего времени ее работы.
- Если от объекта по этой цепочке ссылок можно прийти к “корневой ссылке”, то есть той, которая непосредственно создается в выполняемом коде, - он считается достижимым.
- Все объекты в Java хранятся в специальной области памяти, которая называется куча (heap). В куче все объекты делятся (условно) на простые объекты и “долгожители”.
“Долгожителями” считаются объекты, пережившие много сборок мусора.В итоге общая куча, где хранятся все созданные объекты, была разделена на несколько частей.

1) Eden(рай) сюда попадают объекты после создания. Именно в этой части выделяется память для новых объектов, когда мы пишем new.
2) Survival Space (“место для выживших”) - Область памяти, куда переносятся все объекты, пережившие хотя бы одну сборку мусора.
Survival Space в свою очередь делится на поколения. Каждый объект относится к своему поколению в зависимости от того, сколько сборок мусора он пережил.
Если одну - он относится к “Поколению 1”, если 5 - к “Поколению 5”.
- Вместе Eden и Survival Space образуют область под названием Young Generation (“молодое поколение”).
3) Когда в Survival Space заканчивается место, происходит сборка мусора и объекты пережившие её попадают в место под названием Old Generation (“старое поколение”).
Эти объекты выгоднее хранить отдельно от всех остальных. И только когда область Old Generation заполнена, т.е. даже объектов-долгожителей в программе так много,
что памяти не хватает, производится полная уборка мусора. Она обрабатывает не одну область памяти, а вообще все созданные Java-машиной объекты.





CТРОКИ
https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java





String
-Класс String в Java предназначен для работы со строками в Java. Все строковые литералы, определенные в Java программе
(например, "abc") — это экземпляры класса String.
-Класс реализует интерфейсы Serializable и CharSequence
-final класс, который не может иметь потомков
-immutable класс, то есть его объекты не могут быть изменены после создания. Любые операции над объектом String,
результатом которых должен быть объект класса String, приведут к созданию нового объекта.
-потокобезопасный

Строки можно сложить(конкатенация), сравнить (equals(), equalsIgnoreCase()), перевести в приметив (valueOf()),
перевести в ссылочное число (parseInt()), разбить в массив (split(String regex)), извлечь подстроку
(substring(int beginIndex)),перевести в другой регистр (toLowerCase(),toUpperCase())
https://javarush.ru/groups/posts/759-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch1

StringBuilder
-При работе со строками, которые часто будут модифицироваться, в однопоточной среде. для добавления в конец
строки используется метод .append(value);
-delete(int start, int end) — удаляет подстроку символов начиная с позиции start, заканчивая end
-deleteCharAt(int index) — удаляет символ в позиции index
-insert(int offset, String str) — вставляет строку str в позицию offset. Метод insert также перегружен и может
принимать различные аргументы
-replace(int start, int end, String str) — заменит все символы начиная с позиции start до позиции end на str
-reverse() — меняет порядок всех символов на противоположный
-substring(int start) — вернет подстроку, начиная с позиции start
-substring(int start, int end) — вернет подстроку, начиная с позиции start до позиции end
-не потокобезопасный

StringBuffer
-тоже самое,что и StringBuffer, только потокобесопасный.





ИСКЛЮЧЕНИЯ





Исключения бывают unchecked и сhecked.
-К первой группе относят ситуации, когда возникают исключения, унаследованные из класса Error. Это ошибки, возникающие 
при выполнении программы в результате сбоя работы JVM, переполнения памяти или сбоя системы. Обычно они свидетельствуют
о серьезных проблемах, устранить которые программными средствами невозможно. Такой вид исключений в Java относится
к неконтролируемым (unchecked) на стадии компиляции.
-К этой группе также относят RuntimeException – исключения, наследники класса Exception, генерируемые  JVM во время
выполнения программы. Часто причиной возникновения их являются ошибки программирования. Эти исключения также являются
неконтролируемыми (unchecked) на стадии компиляции, поэтому написание кода по их обработке не является обязательным.


-Ко второй группе относят исключительные ситуации, предвидимые еще на стадии написания программы, и для которых должен
быть написан код обработки. Такие исключения являются контролируемыми (checked). Основная часть работы разработчика на 
Java при работе с исключениями – обработка таких ситуаций.

Try catch
-конструкция try catch служит для обработки ошибок. в блок try помещается код,который может
выкинуть ошибку, если происходит ошибка указанная в скобках catch(Exeption e), то выполнение программы переходит 
в блок catch.
-блок finally может быть,а может и нет. код в блоке выполняется в любом случае.
-throw – используется для возбуждения исключения;
-throws – используется в сигнатуре методов для предупреждения, о том что метод может выбросить исключение.





INPUT OUTPUT STREAM
https://javarush.ru/quests/lectures/questcore.level08.lecture04
https://javarush.ru/groups/posts/2020-vvod-vihvod-v-java-klassih-fileinputstream-fileoutputstream-bufferedinputstream




FileOutputStream реализация абстрактного класса OutoutStream.
-можно перезаписывать файл, можно дописывать в файл с помощью true в конструкторе.
-запись происходит по байтам с помощью метода .write()
-требует try catch, либо проброса выше
-при окончании записи нужно закрыть поток.


FileInputStream реализация абстрактного класса InputStream.
-метод .read() читает из файла по одному байту, преобразует в символы.
-требует try catch, либо проброса выше
-при окончании записи нужно закрыть поток.


BufferedInputStream расширяет FilterInputStream и принимает на вход объект InputStream
или любого его наследника
-читает не по одному файлу,а блоками, сохраняя из в буфер 
В качестве дополнительного параметра принимает размер буфера в байтах.





COLLECTIONS
https://habr.com/ru/post/162017/
https://habr.com/ru/company/luxoft/blog/256877/





Iterable -> Collection -> List -> ArrayList
поумолчанию 10 элементов Object 

Добавление через nameList.add(value); 
1) при добавлении проверяется достаточно ли места в массиве, если нет 
2) увеличивается на 3/2+1 и старый массив копируется в новый(с большим размером)
с помощью native System.arraycopy();
3) после чего value добавляется в конец массива.

Добавление в середину: nameList.add(index, value) 
1) при добавлении проверяется достаточно ли места в массиве, 
2) подготавливается место для нового value с помощью System.arraycopy().
3) перезаписывается значение у элемента с указанным индексом/
при вставке другой коллекции использовать addAll(index, Collection).

Удаление элементов по индексу: nameList.remove(index)
1) Определяется какое количество элементов надо скопировать
2) Копирует элементы используя System.arraycopy()

Удаление элементов по значению: nameList.remove(value)
1) Проходит массив до первого совпадения
2) определяет кол-во элементов для копирования
3) Копирует элементы используя System.arraycopy()

— Быстрый доступ к элементам по индексу за время O(1);
— Доступ к элементам по значению за линейное время O(n);
— Медленный, когда вставляются и удаляются элементы из «середины» списка;
— Позволяет хранить любые значения в том числе и null;
— Не синхронизирован.
https://habr.com/ru/post/128269/




Iterable -> Collection -> List -> LinkedList
Iterable -> Collection -> Queue -> Deque > LinkedList
по умолчанию содержит header и size. header — псевдо-элемент списка. Его значение всегда равно null,
a свойства next и prev всегда указывают на первый и последний элемент списка соответственно.
Внутри LinkedList существует static inner класс Entry,с помощью которого создаются новые элементы.

Добавление через nameList.add(value)
1) создается новый новый экземпляр класса Entry
2) переопределяются указатели на предыдущий и следующий элемент

Добавление в середину через nameList.add(index, value).
1) entry(index) пробегает по всему списку в поисках элемента с указанным индексом
2) если нашел индекс, то переопределяются ссылки на предыдущий и следующий
3) если не нашел, то  IndexOutOfBoundsException

Удалить можно первый removeFirst() O(1), последний removeLast()  O(1), по индексу remove(index) O(n), по значению
remove(value) O(n).

Удаление по значению: nameList.remove(value)
1) поиск первого элемента с соответствующим значением
2) удаление элемента
3) переопределение указателей на предыдущий и следующий элемент

— Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1);
— На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n).
Однако, на добавление и удаление из середины списка, используя ListIterator.add() и ListIterator.remove(),
потребуется O(1);
— Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует
соответствующие классы-обертки;
— Не синхронизирован.
https://habr.com/ru/post/127864/


Iterable -> Collection -> List -> Vector
устарел, не рекомендуется к использованию


Iterable -> Collection -> Queue -> PriorityQueue
Неограниченная (unbounded) очередь. Элементы сортируются в порядке возрастания,
и допускается дублирование элементов. должен быть реализован компаратор для сравнения, не допускаются элементы null


Iterable -> Collection -> Deque -> ArreayDeque
Двунаправленная очередь. Можно положить в конец и в начало. Извлечь из конца и из начала, с удалением элемента и без.


Iterable -> Collection -> Set -> HashSet
то же самое что и HashMap, только значения добавляются на место ключа,а на место значения добавляется пустой Object.
добавляются только уникальные значения(ключи) порядок добавления рандомный.


Iterable -> Collection -> Set -> LinkedHashSet
Поддерживает связный список элементов в том порядке, в котором они вставлялись.


Iterable -> Collection -> Set -> SortedSet -> TreeSet
Хранит только уникальные данные в отсортированном виде по возрастанию. 
https://habr.com/ru/post/65617/
https://habr.com/ru/post/66926/


Map -> HashMap
по умолчанию 16 пустых корзин. Ключи и значения могут быть любых типов, в том числе и null.
hashmap, содержит ряд свойств:
-table — Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений;
-loadFactor — Коэффициент загрузки. Значение по умолчанию 0.75;
-threshold — Предельное количество элементов, при достижении которого,
размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (capacity * loadFactor);
-size — Количество элементов HashMap-а;

Добавление элементов nameMap.put(key, value);
1) ключ проверяется на равенство null. Если != null 
1.1) если ключ == null,то вызывается метод putForNullKey(value)
1.2) все элементы цепочки просматриваются на наличие ключа null,если найден,то value перезаписывается
1.3) если ключ с значением null не найден, то будет вызван метод addEntry()
2) генерируется хэш на основе ключа. Для генерации используется метод hash(hashCode), в который передается
key.hashCode().
3) метод indexFor(hash, tableLength), определяет позицию в массиве, куда будет помещен элемент.
4) если корзина пуста вызывается метод addEntry(hash, key, value, index) для добавления нового элемента.
если в корзине есть элемент с таким же ключом, то перезаписывается, если есть элемент, а по ключу совпадений нет,
то помещается в начало цепочки

-При заполнении HashMap-ы она автоматически увеличивается вдвое, после чего происходит перераспределение всех
 элементов.
при удалении элемента размер не уменьшается, но при необходимости можно сделать hashmap = new HashMap<?, ?>(hashmap);

— Добавление элемента выполняется за время O(1)
— Операции получения и удаления элемента могут выполняться за время O(1). В самом худшем случае, время
выполнения может составить ?(n) (все элементы в одной цепочке);
— Ключи и значения могут быть любых типов, в том числе и null.
— Для хранения примитивных типов используются соответствующие классы-оберки;
— Не синхронизирован.
https://habr.com/ru/post/128017/





Data APi
https://www.examclouds.com/ru/java/java-core-russian/new-date-time-api





- LocalDate представляет время с годом, месяцем, днем месяца
- LocalTime представляет часы, минуты, секунды, милесекундами
- LocalDateTime комбинация вышеперечисленного 





СЕРИАЛИЗАЦИЯ





-Сериализация (Serialization) - процесс преобразования структуры данных в линейную последовательность байтов
для дальнейшей
передачи или сохранения. Сериализованные объекты можно затем восстановить (десериализовать).

-Существует два способа сериализации: 1) интерфейс Serializable 2) интерфейс Externalizable

1) работает через Reflection API - класс разбирается как набор полей, каждое из которых пишется в выходной поток. Эта 
операция неоптимальна по производительности. 
1.1 запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, 
идентификаторы полей класса);
1.2 рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
1.3 запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
1.4 рекурсивную запись объектов, которые являются полями сериализуемого объекта.
- ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими
ссылками.
- Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока.
Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров
родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.
- Поля класса, помеченные модификатором transient, не сериализуются.
- При стандартной сериализации поля, имеющие модификатор static, не сериализуются.
- Поля с модификатором final сериализуются как и обычные.

- если необходимо использовать кастомную сериализацию, тогда используется интерфейс Еxternalizable,  который позволяет
применение пользовательской логики сериализации. Способ сериализации и десериализации описывается в методах
writeExternal() и readExternal(). Во время десериализации вызывается конструктор без параметров, а потом уже на
созданном объекте вызывается метод readExternal

- если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,
 а не метод по умолчанию :
- writeObject() - запись объекта в поток;
- readObject() - чтение объекта из потока;
- writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;
- readResolve() - позволяет заменить на себя другой объект после чтения.

- поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при
использовании Externalizable, поскольку final поля должны быть инициализированы в конструкторе, а после этого в
readExternal() изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект
с final полем необходимо использовать только стандартную сериализацию.

- если поле объявлено transient, то при десериализации объекта оно принимает значение по умолчанию.





OPTIONAL
https://habr.com/ru/post/346782/
https://vertex-academy.com/tutorials/ru/java-8-optional/
https://habr.com/ru/post/225641/
https://habr.com/ru/post/540080/





- Optional избавляет от проверки на null,является контейнером (оберткой) для значений которая также может
безопасно содержать null.

- Для создания Optional используются методы:

- Optional.of() -  нельзя передавать null
- Optional.ofNullable() - передавать null можно безопасно
- Optional.empty() - для создания пустого Optional
- Optional.get() - Для получения значения из Optional
- Optional.isPresent() - возвращает true, если значение в нем присутствует, иначе возвращает false
- Optional.ifPresent() - выполняет переданное действие, если значение в Optional присутствует, иначе игнорирует его.
- Optional.orElse() - возвращает переданное значение, если Optional пустой
- Optional.orElseGet() - если объект не найден, Optional оставляет пространство для «Варианта Б» —
можно выполнить другой метод
- Optional.orElseThrow() - бросает переданное исключение , если Optional пустой
- Optional.map() - служит для преобразования значения внутри Optional. Если Optional пустой преобразование не
будет происходить
- Optional.flatMap - преобразовывает значение внутри Optional, но при этом не оборачивает их





ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ





- Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.
В качестве параметра лямбда-выражение принимает объект типа T:

public interface Predicate<T> {
    boolean test(T t);
}


BinaryOperator<T> принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа T:

public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}


UnaryOperator<T> принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает
результат операций в виде объекта типа T:

public interface UnaryOperator<T> {
    T apply(T t);
}


Function<T,R> представляет функцию перехода от объекта типа T к объекту типа R:

public interface Function<T, R> {
    R apply(T t);
}


Consumer<T> выполняет некоторое действие над объектом типа T, при этом ничего не возвращая:

public interface Consumer<T> {
    void accept(T t);
}


Supplier<T> не принимает никаких аргументов, но должен возвращать объект типа T:

public interface Supplier<T> {
    T get();
}





Stream API
https://habr.com/ru/company/luxoft/blog/270383/





способы создания стрима:

- collection.stream() - создание стрима из коллекции.
- Stream.of(значение1,… значениеN) - из значений
- Arrays.stream(массив) - из массива
- Files.lines(путь_к_файлу) - из файла, каждая строка - отдельный элемент
- collection.parallelStream() - паралельный стрим
- Stream.iterate(начальное_условие, выражение_генерации) - бесконечный стрим
- Stream.generate(выражение_генерации) - бесконечный стрим

Методы работы со стримами:
- существует два вида методов - конвеерные и терминальные, если стрим не кончается терминальным методом, то он будет
работать в ленивом режиме до тех пор, пока не вызовется терминальный метод.

конвеерные методы:
- filter Отфильтровывает записи и возвращает только записи, соответствующие условию
- map - Преобразует каждый элемент стрима
- sorted - Позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator
- skip - Позволяет пропустить N первых элементов
- distinct - Возвращает стрим без дубликатов (для метода equals)
- peek - Возвращает тот же стрим, но применяет функцию к каждому элементу стрима
- limit - Позволяет ограничить выборку определенным количеством первых элементов
- flatMap - Похоже на map, но может создавать из одного элемента несколько
- mapToInt - Аналог map, но возвращает числовой стрим (то есть стрим из числовых примитивов)


терминальные методы:
- collect - Представление результатов в виде коллекций и других структур данных
- forEach - Применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
- forEachOrdered - Применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует
- toArray - Возвращает массив значений стрима
- findFirst - Возвращает первый элемент из стрима (возвращает Optional)
- findAny - Возвращает любой подходящий элемент из стрима (возвращает Optional)
- count - Возвращает количество элементов в стриме


класс Collectors содержит методы:

- toList() - собирает элементы в List
- toSet() - cобирает элементы в множество
- counting() - Подсчитывает количество элементов