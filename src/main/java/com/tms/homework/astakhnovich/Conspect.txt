CТРОКИ
https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java





String
-Класс String в Java предназначен для работы со строками в Java. Все строковые литералы, определенные в Java программе
(например, "abc") — это экземпляры класса String.
-Класс реализует интерфейсы Serializable и CharSequence
-final класс, который не может иметь потомков
-immutable класс, то есть его объекты не могут быть изменены после создания. Любые операции над объектом String,
результатом которых должен быть объект класса String, приведут к созданию нового объекта.
-потокобезопасный

Строки можно сложить(конкатенация), сравнить (equals(), equalsIgnoreCase()), перевести в приметив (valueOf()),
перевести в ссылочное число (parseInt()), разбить в массив (split(String regex)), извлечь подстроку
(substring(int beginIndex)),перевести в другой регистр (toLowerCase(),toUpperCase())
https://javarush.ru/groups/posts/759-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch1

StringBuilder
-При работе со строками, которые часто будут модифицироваться, в однопоточной среде. для добавления в конец
строки используется метод .append(value);
-delete(int start, int end) — удаляет подстроку символов начиная с позиции start, заканчивая end
-deleteCharAt(int index) — удаляет символ в позиции index
-insert(int offset, String str) — вставляет строку str в позицию offset. Метод insert также перегружен и может
принимать различные аргументы
-replace(int start, int end, String str) — заменит все символы начиная с позиции start до позиции end на str
-reverse() — меняет порядок всех символов на противоположный
-substring(int start) — вернет подстроку, начиная с позиции start
-substring(int start, int end) — вернет подстроку, начиная с позиции start до позиции end
-не потокобезопасный

StringBuffer
-тоже самое,что и StringBuffer, только потокобесопасный.





ИСКЛЮЧЕНИЯ





Исключения бывают unchecked и сhecked.
-К первой группе относят ситуации, когда возникают исключения, унаследованные из класса Error. Это ошибки, возникающие 
при выполнении программы в результате сбоя работы JVM, переполнения памяти или сбоя системы. Обычно они свидетельствуют
о серьезных проблемах, устранить которые программными средствами невозможно. Такой вид исключений в Java относится
к неконтролируемым (unchecked) на стадии компиляции.
-К этой группе также относят RuntimeException – исключения, наследники класса Exception, генерируемые  JVM во время
выполнения программы. Часто причиной возникновения их являются ошибки программирования. Эти исключения также являются
неконтролируемыми (unchecked) на стадии компиляции, поэтому написание кода по их обработке не является обязательным.


-Ко второй группе относят исключительные ситуации, предвидимые еще на стадии написания программы, и для которых должен
быть написан код обработки. Такие исключения являются контролируемыми (checked). Основная часть работы разработчика на 
Java при работе с исключениями – обработка таких ситуаций.

Try catch
-конструкция try catch служит для обработки ошибок. в блок try помещается код,который может
выкинуть ошибку, если происходит ошибка указанная в скобках catch(Exeption e), то выполнение программы переходит 
в блок catch.
-блок finally может быть,а может и нет. код в блоке выполняется в любом случае.
-throw – используется для возбуждения исключения;
-throws – используется в сигнатуре методов для предупреждения, о том что метод может выбросить исключение.





INPUT OUTPUT STREAM





FileOutputStream реализация абстрактного класса OutoutStream.
-можно перезаписывать файл, можно дописывать в файл с помощью true в конструкторе.
-запись происходит по байтам с помощью метода .write()
-требует try catch, либо проброса выше
-при окончании записи нужно закрыть поток.



FileInputStream реализация абстрактного класса InputStream.
-метод .read() читает из файла по одному байту, преобразует в символы.
-требует try catch, либо проброса выше
-при окончании записи нужно закрыть поток.

https://javarush.ru/quests/lectures/questcore.level08.lecture04
https://javarush.ru/groups/posts/2020-vvod-vihvod-v-java-klassih-fileinputstream-fileoutputstream-bufferedinputstream


BufferedInputStream расширяет FilterInputStream и принимает на вход объект InputStream
или любого его наследника
-читает не по одному файлу,а блоками, сохраняя из в буфер 
В качестве дополнительного параметра принимает размер буфера в байтах.





COLLECTIONS
https://habr.com/ru/post/162017/
https://habr.com/ru/company/luxoft/blog/256877/





Iterable -> Collection -> List -> ArrayList
поумолчанию 10 элементов Object 

Добавление через nameList.add(value); 
1) при добавлении проверяется достаточно ли места в массиве, если нет 
2) увеличивается на 3/2+1 и старый массив копируется в новый(с большим размером)
с помощью native System.arraycopy();
3) после чего value добавляется в конец массива.

Добавление в середину: nameList.add(index, value) 
1) при добавлении проверяется достаточно ли места в массиве, 
2) подготавливается место для нового value с помощью System.arraycopy().
3) перезаписывается значение у элемента с указанным индексом/
при вставке другой коллекции использовать addAll(index, Collection).

Удаление элементов по индексу: nameList.remove(index)
1) Определяется какое количество элементов надо скопировать
2) Копирует элементы используя System.arraycopy()

Удаление элементов по значению: nameList.remove(value)
1) Проходит массив до первого совпадения
2) определяет кол-во элементов для копирования
3) Копирует элементы используя System.arraycopy()

— Быстрый доступ к элементам по индексу за время O(1);
— Доступ к элементам по значению за линейное время O(n);
— Медленный, когда вставляются и удаляются элементы из «середины» списка;
— Позволяет хранить любые значения в том числе и null;
— Не синхронизирован.
https://habr.com/ru/post/128269/




Iterable -> Collection -> List -> LinkedList
Iterable -> Collection -> Queue -> Deque > LinkedList
по умолчанию содержит header и size. header — псевдо-элемент списка. Его значение всегда равно null,
a свойства next и prev всегда указывают на первый и последний элемент списка соответственно.
Внутри LinkedList существует static inner класс Entry,с помощью которого создаются новые элементы.

Добавление через nameList.add(value)
1) создается новый новый экземпляр класса Entry
2) переопределяются указатели на предыдущий и следующий элемент

Добавление в середину через nameList.add(index, value).
1) entry(index) пробегает по всему списку в поисках элемента с указанным индексом
2) если нашел индекс, то переопределяются ссылки на предыдущий и следующий
3) если не нашел, то  IndexOutOfBoundsException

Удалить можно первый removeFirst() O(1), последний removeLast()  O(1), по индексу remove(index) O(n), по значению
remove(value) O(n).

Удаление по значению: nameList.remove(value)
1) поиск первого элемента с соответствующим значением
2) удаление элемента
3) переопределение указателей на предыдущий и следующий элемент

— Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1);
— На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n).
Однако, на добавление и удаление из середины списка, используя ListIterator.add() и ListIterator.remove(),
потребуется O(1);
— Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует
соответствующие классы-обертки;
— Не синхронизирован.
https://habr.com/ru/post/127864/




Iterable -> Collection -> List -> Vector
устарел, не рекомендуется к использованию




Iterable -> Collection -> Queue -> PriorityQueue
Неограниченная (unbounded) очередь. Элементы сортируются в порядке возрастания,
и допускается дублирование элементов. должен быть реализован компаратор для сравнения, не допускаются элементы null




Iterable -> Collection -> Deque -> ArreayDeque
Двунаправленная очередь. Можно положить в конец и в начало. Извлечь из конца и из начала, с удалением элемента и без.




Iterable -> Collection -> Set -> HashSet
то же самое что и HashMap, только значения добавляются на место ключа,а на место значения добавляется пустой Object.
добавляются только уникальные значения(ключи) порядок добавления рандомный.




Iterable -> Collection -> Set -> LinkedHashSet
Поддерживает связный список элементов в том порядке, в котором они вставлялись.




Iterable -> Collection -> Set -> SortedSet -> TreeSet
Хранит только уникальные данные в отсортированном виде по возрастанию. 
https://habr.com/ru/post/65617/
https://habr.com/ru/post/66926/




Map -> HashMap
по умолчанию 16 пустых корзин. Ключи и значения могут быть любых типов, в том числе и null.
hashmap, содержит ряд свойств:
-table — Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений;
-loadFactor — Коэффициент загрузки. Значение по умолчанию 0.75;
-threshold — Предельное количество элементов, при достижении которого,
размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (capacity * loadFactor);
-size — Количество элементов HashMap-а;

Добавление элементов nameMap.put(key, value);
1) ключ проверяется на равенство null. Если != null 
1.1) если ключ == null,то вызывается метод putForNullKey(value)
1.2) все элементы цепочки просматриваются на наличие ключа null,если найден,то value перезаписывается
1.3) если ключ с значением null не найден, то будет вызван метод addEntry()
2) генерируется хэш на основе ключа. Для генерации используется метод hash(hashCode), в который передается
key.hashCode().
3) метод indexFor(hash, tableLength), определяет позицию в массиве, куда будет помещен элемент.
4) если корзина пуста вызывается метод addEntry(hash, key, value, index) для добавления нового элемента.
если в корзине есть элемент с таким же ключом, то перезаписывается, если есть элемент, а по ключу совпадений нет,
то помещается в начало цепочки

-При заполнении HashMap-ы она автоматически увеличивается вдвое, после чего происходит перераспределение всех
 элементов.
при удалении элемента размер не уменьшается, но при необходимости можно сделать hashmap = new HashMap<?, ?>(hashmap);

— Добавление элемента выполняется за время O(1)
— Операции получения и удаления элемента могут выполняться за время O(1). В самом худшем случае, время
выполнения может составить ?(n) (все элементы в одной цепочке);
— Ключи и значения могут быть любых типов, в том числе и null.
— Для хранения примитивных типов используются соответствующие классы-оберки;
— Не синхронизирован.
https://habr.com/ru/post/128017/





Data APi
https://www.examclouds.com/ru/java/java-core-russian/new-date-time-api





- LocalDate представляет время с годом, месяцем, днем месяца
- LocalTime представляет часы, минуты, секунды, милесекундами
- LocalDateTime комбинация вышеперечисленного 





СЕРИАЛИЗАЦИЯ





-Сериализация (Serialization) - процесс преобразования структуры данных в линейную последовательность байтов
для дальнейшей
передачи или сохранения. Сериализованные объекты можно затем восстановить (десериализовать).

-Существует два способа сериализации: 1) интерфейс Serializable 2) интерфейс Externalizable

1) работает через Reflection API - класс разбирается как набор полей, каждое из которых пишется в выходной поток. Эта 
операция неоптимальна по производительности. 
1.1 запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, 
идентификаторы полей класса);
1.2 рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
1.3 запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
1.4 рекурсивную запись объектов, которые являются полями сериализуемого объекта.
- ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими
ссылками.
- Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока.
Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров
родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.
- Поля класса, помеченные модификатором transient, не сериализуются.
- При стандартной сериализации поля, имеющие модификатор static, не сериализуются.
- Поля с модификатором final сериализуются как и обычные.

- если необходимо использовать кастомную сериализацию, тогда используется интерфейс Еxternalizable,  который позволяет
применение пользовательской логики сериализации. Способ сериализации и десериализации описывается в методах
writeExternal() и readExternal(). Во время десериализации вызывается конструктор без параметров, а потом уже на
созданном объекте вызывается метод readExternal

- если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,
 а не метод по умолчанию :
- writeObject() - запись объекта в поток;
- readObject() - чтение объекта из потока;
- writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;
- readResolve() - позволяет заменить на себя другой объект после чтения.

- поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при
использовании Externalizable, поскольку final поля должны быть инициализированы в конструкторе, а после этого в
readExternal() изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект
с final полем необходимо использовать только стандартную сериализацию.

- если поле объявлено transient, то при десериализации объекта оно принимает значение по умолчанию.





ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ





- Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.
В качестве параметра лямбда-выражение принимает объект типа T:

public interface Predicate<T> {
    boolean test(T t);
}


BinaryOperator<T> принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа T:

public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}


UnaryOperator<T> принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает
результат операций в виде объекта типа T:

public interface UnaryOperator<T> {
    T apply(T t);
}


Function<T,R> представляет функцию перехода от объекта типа T к объекту типа R:

public interface Function<T, R> {
    R apply(T t);
}


Consumer<T> выполняет некоторое действие над объектом типа T, при этом ничего не возвращая:

public interface Consumer<T> {
    void accept(T t);
}


Supplier<T> не принимает никаких аргументов, но должен возвращать объект типа T:

public interface Supplier<T> {
    T get();
}
